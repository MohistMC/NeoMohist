--- a/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -20,6 +_,8 @@
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.NonNullList;
 import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.Container;
@@ -31,6 +_,9 @@
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.entity.BlockEntity;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+import org.bukkit.inventory.InventoryView;
 import org.slf4j.Logger;
 
 public abstract class AbstractContainerMenu {
@@ -62,6 +_,45 @@
     private ContainerSynchronizer synchronizer;
     private boolean suppressRemoteUpdates;
 
+    // CraftBukkit start
+    public boolean checkReachable = true;
+    // Mohist start
+    public InventoryView bukkitView = null;
+
+    public InventoryView getBukkitView(){
+        return bukkitView;
+    }
+
+    // Mohist end
+    public void transferTo(AbstractContainerMenu other, CraftHumanEntity player) {
+        InventoryView source = this.getBukkitView(), destination = other.getBukkitView();
+        ((CraftInventory) source.getTopInventory()).getInventory().onClose(player);
+        ((CraftInventory) source.getBottomInventory()).getInventory().onClose(player);
+        ((CraftInventory) destination.getTopInventory()).getInventory().onOpen(player);
+        ((CraftInventory) destination.getBottomInventory()).getInventory().onOpen(player);
+    }
+    private Component title;
+    public Component getTitle() {
+        // Mohist: null title -> empty title
+        if (this.title == null) {
+            if (this.menuType != null) {
+                ResourceLocation key = BuiltInRegistries.MENU.getKey(this.menuType);
+                if (key == null) {
+                    this.title = Component.literal(this.toString());
+                } else {
+                    this.title = Component.translatable(key.toString());
+                }
+            } else {
+                this.title = Component.literal(this.toString());
+            }
+        }
+        return this.title;
+    }
+    public void setTitle(Component title) {
+        this.title = title;
+    }
+    // CraftBukkit end
+
     protected AbstractContainerMenu(@Nullable MenuType<?> p_38851_, int p_38852_) {
         this.menuType = p_38851_;
         this.containerId = p_38852_;
@@ -150,6 +_,15 @@
         }
     }
 
+    // CraftBukkit start
+    public void broadcastCarriedItem() {
+        this.remoteCarried = this.getCarried().copy();
+        if (this.synchronizer != null) {
+            this.synchronizer.sendCarriedChange(this, this.remoteCarried);
+        }
+    }
+    // CraftBukkit end
+
     public void removeSlotListener(ContainerListener p_38944_) {
         this.containerListeners.remove(p_38944_);
     }
@@ -511,6 +_,11 @@
     }
 
     private boolean tryItemClickBehaviourOverride(Player p_249615_, ClickAction p_250300_, Slot p_249384_, ItemStack p_251073_, ItemStack p_252026_) {
+        // Neo: Fire the ItemStackedOnOtherEvent, and return true if it was cancelled (meaning the event was handled). Returning true will trigger the container to stop processing further logic.
+        if (net.neoforged.neoforge.common.CommonHooks.onItemStackedOn(p_251073_, p_252026_, p_249384_, p_250300_, p_249615_, createCarriedSlotAccess())) {
+            return true;
+        }
+
         FeatureFlagSet featureflagset = p_249615_.level().enabledFeatures();
         return p_252026_.isItemEnabled(featureflagset) && p_252026_.overrideStackedOnOther(p_249384_, p_250300_, p_249615_)
             ? true
