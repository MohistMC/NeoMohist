--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -9,6 +_,7 @@
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.brigadier.CommandDispatcher;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.longs.LongIterator;
@@ -48,6 +_,9 @@
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+
+import jline.console.ConsoleReader;
+import joptsimple.OptionSet;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.FileUtil;
@@ -168,7 +_,7 @@
 import org.slf4j.Logger;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, AutoCloseable {
-    public static final Logger LOGGER = LogUtils.getLogger();
+    private static final Logger LOGGER = LogUtils.getLogger();
     public static final String VANILLA_BRAND = "vanilla";
     private static final float AVERAGE_TICK_TIME_SMOOTHING = 0.8F;
     private static final int TICK_STATS_SPAN = 100;
@@ -188,8 +_,8 @@
         "Demo World", GameType.SURVIVAL, false, Difficulty.NORMAL, false, new GameRules(), WorldDataConfiguration.DEFAULT
     );
     public static final GameProfile ANONYMOUS_PLAYER_PROFILE = new GameProfile(Util.NIL_UUID, "Anonymous Player");
-    public LevelStorageSource.LevelStorageAccess storageSource;
-    public final PlayerDataStorage playerDataStorage;
+    protected final LevelStorageSource.LevelStorageAccess storageSource;
+    protected final PlayerDataStorage playerDataStorage;
     private final List<Runnable> tickables = Lists.newArrayList();
     private MetricsRecorder metricsRecorder = InactiveMetricsRecorder.INSTANCE;
     private ProfilerFiller profiler = this.metricsRecorder.getProfiler();
@@ -200,18 +_,18 @@
     @Nullable
     private MinecraftServer.TimeProfiler debugCommandProfiler;
     private boolean debugCommandProfilerDelayStart;
-    public ServerConnectionListener connection;
-    public final ChunkProgressListenerFactory progressListenerFactory;
+    private final ServerConnectionListener connection;
+    private final ChunkProgressListenerFactory progressListenerFactory;
     @Nullable
     private ServerStatus status;
     @Nullable
     private ServerStatus.Favicon statusIcon;
     private final RandomSource random = RandomSource.create();
-    public final DataFixer fixerUpper;
+    private final DataFixer fixerUpper;
     private String localIp;
     private int port = -1;
     private final LayeredRegistryAccess<RegistryLayer> registries;
-    public Map<ResourceKey<Level>, ServerLevel> levels = Maps.newLinkedHashMap();
+    private final Map<ResourceKey<Level>, ServerLevel> levels = Maps.newLinkedHashMap();
     private PlayerList playerList;
     private volatile boolean running = true;
     private boolean stopped;
@@ -236,7 +_,7 @@
     private long lastOverloadWarningNanos;
     protected final Services services;
     private long lastServerStatus;
-    public final Thread serverThread;
+    private final Thread serverThread;
     private long lastTickNanos = Util.getNanos();
     private long taskExecutionStartNanos = Util.getNanos();
     private long idleTimeNanos;
@@ -251,20 +_,32 @@
     private final ServerFunctionManager functionManager;
     private boolean enforceWhitelist;
     private float smoothedTickTimeMillis;
-    public final Executor executor;
+    private final Executor executor;
     @Nullable
     private String serverId;
-    public MinecraftServer.ReloadableResources resources;
+    private MinecraftServer.ReloadableResources resources;
     private final StructureTemplateManager structureTemplateManager;
     private final ServerTickRateManager tickRateManager;
-    public WorldData worldData;
+    protected final WorldData worldData;
     private final PotionBrewing potionBrewing;
     private volatile boolean isSaving;
     private static final AtomicReference<RuntimeException> fatalException = new AtomicReference<>();
 
+    // CraftBukkit start
+    public org.bukkit.craftbukkit.CraftServer server;
+    public OptionSet options;
+    public org.bukkit.command.ConsoleCommandSender console;
+    public ConsoleReader reader;
+    public static int currentTick = (int) (System.currentTimeMillis() / 50);
+    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
+    public int autosavePeriod;
+    public Commands vanillaCommandDispatcher;
+    private boolean forceTicks;
+    // CraftBukkit end
+
     public static <S extends MinecraftServer> S spin(Function<Thread, S> p_129873_) {
         AtomicReference<S> atomicreference = new AtomicReference<>();
-        Thread thread = new Thread(() -> atomicreference.get().runServer(), "Server thread");
+        Thread thread = new Thread(net.neoforged.fml.util.thread.SidedThreadGroups.SERVER, () -> atomicreference.get().runServer(), "Server thread");
         thread.setUncaughtExceptionHandler((p_177909_, p_177910_) -> LOGGER.error("Uncaught exception in server thread", p_177910_));
         if (Runtime.getRuntime().availableProcessors() > 4) {
             thread.setPriority(8);
@@ -372,6 +_,7 @@
         this.readScoreboard(dimensiondatastorage);
         this.commandStorage = new CommandStorage(dimensiondatastorage);
         WorldBorder worldborder = serverlevel.getWorldBorder();
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.LevelEvent.Load(levels.get(Level.OVERWORLD)));
         if (!serverleveldata.isInitialized()) {
             try {
                 setInitialSpawn(serverlevel, serverleveldata, worldoptions.generateBonusChest(), flag);
@@ -421,6 +_,7 @@
                 );
                 worldborder.addListener(new BorderChangeListener.DelegateBorderChangeListener(serverlevel1.getWorldBorder()));
                 this.levels.put(resourcekey1, serverlevel1);
+                net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.LevelEvent.Load(levels.get(resourcekey)));
             }
         }
 
@@ -432,6 +_,7 @@
             p_177898_.setSpawn(BlockPos.ZERO.above(80), 0.0F);
         } else {
             ServerChunkCache serverchunkcache = p_177897_.getChunkSource();
+            if (net.neoforged.neoforge.event.EventHooks.onCreateWorldSpawn(p_177897_, p_177898_)) return;
             ChunkPos chunkpos = new ChunkPos(serverchunkcache.randomState().sampler().findSpawnPosition());
             int i = serverchunkcache.getGenerator().getSpawnHeight(p_177897_);
             if (i < p_177897_.getMinBuildHeight()) {
@@ -484,7 +_,7 @@
         serverleveldata.setGameType(GameType.SPECTATOR);
     }
 
-    public void prepareLevels(ChunkProgressListener p_129941_) {
+    private void prepareLevels(ChunkProgressListener p_129941_) {
         ServerLevel serverlevel = this.overworld();
         LOGGER.info("Preparing start region for dimension {}", serverlevel.dimension().location());
         BlockPos blockpos = serverlevel.getSharedSpawnPos();
@@ -513,6 +_,7 @@
                     ChunkPos chunkpos = new ChunkPos(k);
                     serverlevel1.getChunkSource().updateChunkForced(chunkpos, true);
                 }
+                net.neoforged.neoforge.common.world.chunk.ForcedChunkManager.reinstatePersistentChunks(serverlevel1, forcedchunkssaveddata);
             }
         }
 
@@ -620,6 +_,7 @@
         for (ServerLevel serverlevel2 : this.getAllLevels()) {
             if (serverlevel2 != null) {
                 try {
+                    net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.LevelEvent.Unload(serverlevel2));
                     serverlevel2.close();
                 } catch (IOException ioexception1) {
                     LOGGER.error("Exception closing the level", (Throwable)ioexception1);
@@ -666,9 +_,11 @@
                 throw new IllegalStateException("Failed to initialize server");
             }
 
+            net.neoforged.neoforge.server.ServerLifecycleHooks.handleServerStarted(this);
             this.nextTickTimeNanos = Util.getNanos();
             this.statusIcon = this.loadStatusIcon().orElse(null);
             this.status = this.buildServerStatus();
+            resetStatusCache(status);
 
             while (this.running) {
                 long i;
@@ -714,6 +_,8 @@
                 this.isReady = true;
                 JvmProfiler.INSTANCE.onServerTick(this.smoothedTickTimeMillis);
             }
+            net.neoforged.neoforge.server.ServerLifecycleHooks.handleServerStopping(this);
+            net.neoforged.neoforge.server.ServerLifecycleHooks.expectServerStopped(); // Forge: Has to come before MinecraftServer#onServerCrash to avoid race conditions
         } catch (Throwable throwable1) {
             LOGGER.error("Encountered an unexpected exception", throwable1);
             CrashReport crashreport = constructOrExtractCrashReport(throwable1);
@@ -725,6 +_,7 @@
                 LOGGER.error("We were unable to save this crash report to disk.");
             }
 
+            net.neoforged.neoforge.server.ServerLifecycleHooks.expectServerStopped(); // Forge: Has to come before MinecraftServer#onServerCrash to avoid race conditions
             this.onServerCrash(crashreport);
         } finally {
             try {
@@ -737,6 +_,7 @@
                     this.services.profileCache().clearExecutor();
                 }
 
+                net.neoforged.neoforge.server.ServerLifecycleHooks.handleServerStopped(this);
                 this.onServerExit();
             }
         }
@@ -792,6 +_,11 @@
         return this.runningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
     }
 
+    private void executeModerately() {
+        this.runAllTasks();
+        java.util.concurrent.locks.LockSupport.parkNanos("executing tasks", 1000L);
+    }
+
     public static boolean throwIfFatalException() {
         RuntimeException runtimeexception = fatalException.get();
         if (runtimeexception != null) {
@@ -825,7 +_,7 @@
         }
     }
 
-    public TickTask wrapRunnable(Runnable p_129852_) {
+    protected TickTask wrapRunnable(Runnable p_129852_) {
         return new TickTask(this.tickCount, p_129852_);
     }
 
@@ -901,11 +_,13 @@
     public void tickServer(BooleanSupplier p_129871_) {
         long i = Util.getNanos();
         this.tickCount++;
+        net.neoforged.neoforge.event.EventHooks.fireServerTickPre(p_129871_, this);
         this.tickRateManager.tick();
         this.tickChildren(p_129871_);
         if (i - this.lastServerStatus >= STATUS_EXPIRE_TIME_NANOS) {
             this.lastServerStatus = i;
             this.status = this.buildServerStatus();
+            resetStatusCache(status);
         }
 
         this.ticksUntilAutosave--;
@@ -927,6 +_,7 @@
         this.smoothedTickTimeMillis = this.smoothedTickTimeMillis * 0.8F + (float)j / (float)TimeUtil.NANOSECONDS_PER_MILLISECOND * 0.19999999F;
         this.logTickMethodTime(i);
         this.profiler.pop();
+        net.neoforged.neoforge.event.EventHooks.fireServerTickPost(p_129871_, this);
     }
 
     private void logTickMethodTime(long p_321837_) {
@@ -935,6 +_,16 @@
         }
     }
 
+    private static final com.google.gson.Gson GSON = new com.google.gson.Gson();
+    private String cachedServerStatus; // NEO: cache the server status json in case a client spams requests
+    private void resetStatusCache(ServerStatus status) {
+        this.cachedServerStatus = GSON.toJson(ServerStatus.CODEC.encodeStart(com.mojang.serialization.JsonOps.INSTANCE, status)
+                .result().orElseThrow());
+    }
+    public String getStatusJson() {
+        return cachedServerStatus;
+    }
+
     private int computeNextAutosaveInterval() {
         float f;
         if (this.tickRateManager.isSprinting()) {
@@ -966,7 +_,8 @@
             Optional.of(serverstatus$players),
             Optional.of(ServerStatus.Version.current()),
             Optional.ofNullable(this.statusIcon),
-            this.enforceSecureProfile()
+            this.enforceSecureProfile(),
+            true //TODO Neo: Possible build a system which indicates what the status of the modded server is.
         );
     }
 
@@ -996,7 +_,8 @@
         this.getFunctions().tick();
         this.profiler.popPush("levels");
 
-        for (ServerLevel serverlevel : this.getAllLevels()) {
+        for(ServerLevel serverlevel : this.getWorldArray()) {
+            long tickStart = Util.getNanos();
             this.profiler.push(() -> serverlevel + " " + serverlevel.dimension().location());
             if (this.tickCount % 20 == 0) {
                 this.profiler.push("timeSync");
@@ -1005,6 +_,7 @@
             }
 
             this.profiler.push("tick");
+            net.neoforged.neoforge.event.EventHooks.fireLevelTickPre(serverlevel, p_129954_);
 
             try {
                 serverlevel.tick(p_129954_);
@@ -1013,16 +_,18 @@
                 serverlevel.fillReportDetails(crashreport);
                 throw new ReportedException(crashreport);
             }
+            net.neoforged.neoforge.event.EventHooks.fireLevelTickPost(serverlevel, p_129954_);
 
             this.profiler.pop();
             this.profiler.pop();
+            perWorldTickTimes.computeIfAbsent(serverlevel.dimension(), k -> new long[100])[this.tickCount % 100] = Util.getNanos() - tickStart;
         }
 
         this.profiler.popPush("connection");
         this.getConnection().tick();
         this.profiler.popPush("players");
         this.playerList.tick();
-        if (SharedConstants.IS_RUNNING_IN_IDE && this.tickRateManager.runsNormally()) {
+        if (net.neoforged.neoforge.gametest.GameTestHooks.isGametestEnabled() && this.tickRateManager.runsNormally()) {
             GameTestTicker.SINGLETON.tick();
         }
 
@@ -1089,6 +_,16 @@
         return this.levels.get(p_129881_);
     }
 
+    public void addLevel(ServerLevel level) {
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new LevelEvent.Load(levels.get(Level.OVERWORLD)));
+        this.levels.put(level.dimension(), level);
+    }
+
+    public void removeLevel(ServerLevel level) {
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new LevelEvent.Unload(levels.get(Level.OVERWORLD)));
+        this.levels.remove(level.dimension(), level);
+    }
+
     public Set<ResourceKey<Level>> levelKeys() {
         return this.levels.keySet();
     }
@@ -1118,7 +_,7 @@
 
     @DontObfuscate
     public String getServerModName() {
-        return "vanilla";
+        return net.neoforged.neoforge.internal.BrandingControl.getServerBranding();
     }
 
     public SystemReport fillSystemReport(SystemReport p_177936_) {
@@ -1441,7 +_,7 @@
 
     public CompletableFuture<Void> reloadResources(Collection<String> p_129862_) {
         CompletableFuture<Void> completablefuture = CompletableFuture.<ImmutableList>supplyAsync(
-                () -> p_129862_.stream().map(this.packRepository::getPack).filter(Objects::nonNull).map(Pack::open).collect(ImmutableList.toImmutableList()),
+                () -> this.packRepository.rebuildSelected(p_129862_).stream().map(Pack::open).collect(ImmutableList.toImmutableList()),
                 this
             )
             .thenCompose(
@@ -1478,6 +_,7 @@
                     this.getPlayerList().reloadResources();
                     this.functionManager.replaceLibrary(this.resources.managers.getFunctionLibrary());
                     this.structureTemplateManager.onResourceManagerReload(this.resources.resourceManager);
+                    this.getPlayerList().getPlayers().forEach(this.getPlayerList()::sendPlayerPermissionLevel); //Forge: Fix newly added/modified commands not being sent to the client when commands reload.
                 },
                 this
             );
@@ -1495,8 +_,10 @@
         FeatureFlagSet featureflagset = p_249869_ ? FeatureFlagSet.of() : p_341632_.enabledFeatures();
         FeatureFlagSet featureflagset1 = p_249869_ ? FeatureFlags.REGISTRY.allFlags() : p_341632_.enabledFeatures();
         p_248681_.reload();
+        DataPackConfig.DEFAULT.addModPacks(net.neoforged.neoforge.common.CommonHooks.getModDataPacks());
+        datapackconfig.addModPacks(net.neoforged.neoforge.common.CommonHooks.getModDataPacks());
         if (p_341620_) {
-            return configureRepositoryWithSelection(p_248681_, List.of("vanilla"), featureflagset, false);
+            return configureRepositoryWithSelection(p_248681_, net.neoforged.neoforge.common.CommonHooks.getModDataPacksWithVanilla(), featureflagset, false);
         } else {
             Set<String> set = Sets.newLinkedHashSet();
 
@@ -1542,6 +_,8 @@
                 set.add("vanilla");
             }
 
+            net.neoforged.neoforge.resource.ResourcePackLoader.reorderNewlyDiscoveredPacks(set, datapackconfig.getEnabled(), p_248681_);
+
             return configureRepositoryWithSelection(p_248681_, set, featureflagset, true);
         }
     }
@@ -1712,6 +_,31 @@
 
     public abstract boolean isSingleplayerOwner(GameProfile p_129840_);
 
+    private Map<ResourceKey<Level>, long[]> perWorldTickTimes = Maps.newIdentityHashMap();
+    @Nullable
+    public long[] getTickTime(ResourceKey<Level> dim) {
+        return perWorldTickTimes.get(dim);
+    }
+
+    @Deprecated //Forge Internal use Only, You can screw up a lot of things if you mess with this map.
+    public synchronized Map<ResourceKey<Level>, ServerLevel> forgeGetWorldMap() {
+        return this.levels;
+    }
+    private int worldArrayMarker = 0;
+    private int worldArrayLast = -1;
+    private ServerLevel[] worldArray;
+    @Deprecated //Forge Internal use Only, use to protect against concurrent modifications in the world tick loop.
+    public synchronized void markWorldsDirty() {
+        worldArrayMarker++;
+    }
+    private ServerLevel[] getWorldArray() {
+        if (worldArrayMarker == worldArrayLast && worldArray != null)
+            return worldArray;
+        worldArray = this.levels.values().stream().toArray(x -> new ServerLevel[x]);
+        worldArrayLast = worldArrayMarker;
+        return worldArray;
+    }
+
     public void dumpServerProperties(Path p_177911_) throws IOException {
     }
 
@@ -1875,6 +_,10 @@
         return this.worldData;
     }
 
+    public MinecraftServer.ReloadableResources getServerResources() {
+         return resources;
+    }
+
     public RegistryAccess.Frozen registryAccess() {
         return this.registries.compositeAccess();
     }
@@ -2011,11 +_,11 @@
     public static record ServerResourcePackInfo(UUID id, String url, String hash, boolean isRequired, @Nullable Component prompt) {
     }
 
-    public static class TimeProfiler {
+    static class TimeProfiler {
         final long startNanos;
         final int startTick;
 
-        public TimeProfiler(long p_177958_, int p_177959_) {
+        TimeProfiler(long p_177958_, int p_177959_) {
             this.startNanos = p_177958_;
             this.startTick = p_177959_;
         }
